import { EDITOR } from '../core/manager.js';

/**
 * 表格重置弹出窗
 */
const tableInitPopupDom = `
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_base"><span>基础插件设置</span>
</div>
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_injection"><span>注入设置</span>
</div>
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_refresh_template"><span>表格总结设置</span>
</div>
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_step"><span>独立填表设置</span>
</div>
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_to_chat"><span>前端表格（状态栏）</span>
</div>
<div class="checkbox flex-container">
    <input type="checkbox" id="table_init_structure"><span>表格结构</span>
</div>
`;

/**
 * 过滤表格数据弹出窗口
 *
 * 这个函数创建一个弹出窗口，允许用户选择性地重置表格数据的不同部分。
 * 用户可以通过勾选复选框来选择要重置的数据项，例如基础设置、消息模板、表格结构等。
 *
 * @param {object} originalData 原始表格数据，函数会根据用户的选择过滤这些数据。
 * @returns {Promise<{filterData: object|null, confirmation: boolean}>}
 *          返回一个Promise，resolve一个对象，包含：
 *          - filterData: 过滤后的数据对象，只包含用户选择重置的部分，如果用户取消操作，则为null。
 *          - confirmation: 布尔值，表示用户是否点击了“继续”按钮确认操作。
 */
export async function filterTableDataPopup(originalData, title, warning) {
    const $tableInitPopup = $('<div></div>')
        .append($(`<span>${title}</span>`))
        .append('<br>')
        .append($(`<span style="color: rgb(211, 39, 39)">${warning}</span>`))
        .append($(tableInitPopupDom))
    const confirmation = new EDITOR.Popup($tableInitPopup, EDITOR.POPUP_TYPE.CONFIRM, '', { okButton: "继续", cancelButton: "取消" });
    let waitingBoolean = {};
    let waitingRegister = new Proxy({}, {     // 创建一个 Proxy 对象用于监听和处理 waitingBoolean 对象的属性设置
        set(target, prop, value) {
            $(confirmation.dlg).find(value).change(function () {
                // 当复选框状态改变时，将复选框的选中状态 (this.checked) 存储到 waitingBoolean 对象中
                waitingBoolean[prop] = this.checked;
                console.log(Object.keys(waitingBoolean).filter(key => waitingBoolean[key]).length);
            });
            target[prop] = value;
            waitingBoolean[prop] = false;
            return true;
        },
        get(target, prop) {
            // 判断是否存在
            if (!(prop in target)) {
                return '#table_init_basic';
            }
            return target[prop];
        }
    });


    // 设置不同部分的默认复选框
    // 插件设置
    waitingRegister.isAiReadTable = '#table_init_base';
    waitingRegister.isAiWriteTable = '#table_init_base';
    // 注入设置
    waitingRegister.injection_mode = '#table_init_injection';
    waitingRegister.deep = '#table_init_injection';
    waitingRegister.message_template = '#table_init_injection';
    // 重新整理表格设置
    waitingRegister.confirm_before_execution = '#table_init_refresh_template';
    waitingRegister.use_main_api = '#table_init_refresh_template';
    waitingRegister.custom_temperature = '#table_init_refresh_template';
    waitingRegister.custom_max_tokens = '#table_init_refresh_template';
    waitingRegister.custom_top_p = '#table_init_refresh_template';
    waitingRegister.bool_ignore_del = '#table_init_refresh_template';
    waitingRegister.ignore_user_sent = '#table_init_refresh_template';
    waitingRegister.clear_up_stairs = '#table_init_refresh_template';
    waitingRegister.use_token_limit = '#table_init_refresh_template';
    waitingRegister.rebuild_token_limit_value = '#table_init_refresh_template';
    waitingRegister.refresh_system_message_template = '#table_init_refresh_template';
    waitingRegister.refresh_user_message_template = '#table_init_refresh_template';
    // 双步设置
    waitingRegister.step_by_step = '#table_init_step';
    waitingRegister.step_by_step_use_main_api = '#table_init_step';
    waitingRegister.bool_silent_refresh = '#table_init_step';
    // 前端表格
    waitingRegister.isTableToChat = '#table_init_to_chat';
    waitingRegister.show_settings_in_extension_menu = '#table_init_to_chat';
    waitingRegister.alternate_switch = '#table_init_to_chat';
    waitingRegister.show_drawer_in_extension_list = '#table_init_to_chat';
    waitingRegister.table_to_chat_can_edit = '#table_init_to_chat';
    waitingRegister.table_to_chat_mode = '#table_init_to_chat';
    waitingRegister.to_chat_container = '#table_init_to_chat';
    // 所有表格结构数据
    waitingRegister.tableStructure = '#table_init_structure';



    // 显示确认弹出窗口，并等待用户操作
    await confirmation.show();
    if (!confirmation.result) return { filterData: null, confirmation: false };

    // 过滤出用户选择的数据
    const filterData = Object.keys(waitingBoolean).filter(key => waitingBoolean[key]).reduce((acc, key) => {
        acc[key] = originalData[key];
        return acc;
    }, {})

    // 返回过滤后的数据和确认结果
    return { filterData, confirmation };
}

export const defaultSettings = {
    // 插件总开关
    isExtensionAble: true,
    // 调试模式
    tableDebugModeAble: false,
    // AI读表开关
    isAiReadTable: true,
    // AI改表开关
    isAiWriteTable: true,
    // 表格注入模式
    injection_mode: 'injection_off',
    // 表格深度
    deep: 0,
    // 消息模板
    message_template: `现在请基于我们的对话，使用json格式对你认为有价值的、需要长期记住的人/事/物进行信息结构化整理，你只能返回一个不带任何其他描述的、可被json解析的列表，列表的每个条目都应该包含'name'和'description'字段，其中'name'是结构化信息的名称，'description'是结构化信息的描述。
[
    {
        "name": "表格名称",
        "description":"表格描述"
    }
]`,
    // 运行策略
    step_by_step: false,
    // 确认执行
    confirm_before_execution: true,
    // 使用主API
    use_main_api: true,
    // 分步执行使用主API
    step_by_step_use_main_api: true,
    // 忽略删除
    bool_ignore_del: false,
    // 忽略用户发送
    ignore_user_sent: true,
    // 静默刷新
    bool_silent_refresh: false,
    // token限制
    use_token_limit: false,
    // token限制值
    rebuild_token_limit_value: 10000,
    // 聊天记录限制
    clear_up_stairs: 9,
    // 自定义API温度
    custom_temperature: 1.0,
    // 表格推送到对话
    isTableToChat: false,
    // 在扩展菜单中显示设置
    show_settings_in_extension_menu: true,
    // 穿插模式
    alternate_switch: true,
    // 在扩展列表中显示抽屉
    show_drawer_in_extension_list: false,
    // 推送到对话的表格可编辑
    table_to_chat_can_edit: false,
    // 表格推送到对话的模式
    table_to_chat_mode: 'context_bottom',
    // 单元格宽度模式
    table_cell_width_mode: 'single_line',
    // Claw轮询API
    use_claw_polling_api: false,
};
